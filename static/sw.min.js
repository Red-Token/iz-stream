// (() => {
// 	'use strict';
// 	let e = !1;
// 	self.addEventListener('install', () => {
// 		self.skipWaiting();
// 	}),
// 		self.addEventListener('fetch', (s) => {
// 			const t = ((s) => {
// 				const {url: t} = s.request;
// 				return (
// 					console.log('zool is soo cool' + t),
// 					console.log(self.registration.scope),
// 					t.includes(self.registration.scope + 'webtorrent/')
// 						? t.includes(self.registration.scope + 'webtorrent/keepalive/')
// 							? new Response()
// 							: t.includes(self.registration.scope + 'webtorrent/cancel/')
// 								? new Response(
// 										new ReadableStream({
// 											cancel() {
// 												e = !0;
// 											}
// 										})
// 									)
// 								: (async function ({request: s}) {
// 										const {url: t, method: n, headers: o, destination: l} = s,
// 											r = await clients.matchAll({type: 'window', includeUncontrolled: !0});
// 										console.log('Zurrano!');
// 										const [a, i] = await new Promise((e) => {
// 											for (const s of r) {
// 												const r = new MessageChannel(),
// 													{port1: a, port2: i} = r;
// 												(a.onmessage = ({data: s}) => {
// 													e([s, a]);
// 												}),
// 													s.postMessage(
// 														{
// 															url: t,
// 															method: n,
// 															headers: Object.fromEntries(o.entries()),
// 															scope: self.registration.scope,
// 															destination: l,
// 															type: 'webtorrent'
// 														},
// 														[i]
// 													);
// 											}
// 										});
// 										let c = null;
// 										const d = () => {
// 											i.postMessage(!1), clearTimeout(c), (i.onmessage = null);
// 										};
// 										return 'STREAM' !== a.body
// 											? (d(), new Response(a.body, a))
// 											: new Response(
// 													new ReadableStream({
// 														pull: (s) =>
// 															new Promise((t) => {
// 																(i.onmessage = ({data: e}) => {
// 																	e ? s.enqueue(e) : (d(), s.close()), t();
// 																}),
// 																	e ||
// 																		(clearTimeout(c),
// 																		'document' !== l &&
// 																			(c = setTimeout(() => {
// 																				d(), t();
// 																			}, 5e3))),
// 																	i.postMessage(!0);
// 															}),
// 														cancel() {
// 															d();
// 														}
// 													}),
// 													a
// 												);
// 									})(s)
// 						: null
// 				);
// 			})(s);
// 			t && s.respondWith(t);
// 		}),
// 		self.addEventListener('activate', () => {
// 			self.clients.claim();
// 		});
// })();
// //# sourceMappingURL=sw.min.js.map
